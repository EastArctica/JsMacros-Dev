import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.SourceSetContainer
import org.gradle.api.tasks.bundling.Zip
import org.gradle.api.tasks.javadoc.Javadoc
import org.gradle.external.javadoc.CoreJavadocOptions
import org.gradle.external.javadoc.StandardJavadocDocletOptions
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

plugins {
    // see https://fabricmc.net/develop/ for new versions
    id 'fabric-loom' version '1.13-SNAPSHOT' apply false
    // see https://projects.neoforged.net/neoforged/moddevgradle for new versions
    id 'net.neoforged.moddev' version '2.0.123' apply false
}

def documentationProjects = [project(':common'), project(':extension')]
def docletJarFile = layout.projectDirectory.file('buildSrc/build/libs/buildSrc.jar').asFile
def docsBuildDir = layout.buildDirectory.dir('docs').get().asFile
def distDir = layout.projectDirectory.dir('dist')
def distDirFile = distDir.asFile
def modIdProvider = providers.gradleProperty('mod_id')
def mcVersionProvider = providers.gradleProperty('minecraft_version')
def channelProvider = providers.gradleProperty('channel').orElse('release')
def modVersionBaseProvider = providers.gradleProperty('mod_version').orElse(providers.gradleProperty('version'))
def betaNumberProvider = providers.gradleProperty('beta_number')
def alphaDateProvider = providers.gradleProperty('alpha_date')
def buildShaProvider = providers.gradleProperty('build_sha')

def dateFormatter = DateTimeFormatter.ofPattern('yyyyMMdd')
def computedAlphaDateProvider = providers.provider {
    alphaDateProvider.orElse(
            providers.provider { ZonedDateTime.now(ZoneId.of('America/New_York')).format(dateFormatter) }
    ).get()
}

def computedBuildShaProvider = providers.provider {
    def sha = buildShaProvider.orElse(
            providers.provider { System.getenv('GITHUB_SHA') ?: 'local' }
    ).get()
    return sha.take(7)
}

def computedVersionProvider = providers.provider {
    def base = modVersionBaseProvider.get()
    switch (channelProvider.get()) {
        case 'release':
            return base
        case 'beta':
            def betaNum = betaNumberProvider.orElse('1').get()
            return "${base}-beta.${betaNum}"
        case 'alpha':
            return "${base}-alpha.${computedAlphaDateProvider.get()}"
        default:
            return "${base}-dev-${computedBuildShaProvider.get()}"
    }
}

def modId = modIdProvider.get()
def mcVersion = mcVersionProvider.get()
def channel = channelProvider.get()
version = computedVersionProvider.get()

def loaders = ['fabric', 'neoforge']
def extensions = [
    [path: ':extension:graal:python', extId: 'graalpy']
]
def artifactBaseName = providers.provider { "${modId}-${mcVersion}-${channel}-${version}" }

gradle.projectsEvaluated {
    def mainSourceSets = documentationProjects.collect {
        it.extensions.getByType(SourceSetContainer).named('main').get()
    }
    def documentationSources = files(mainSourceSets.collect { it.allJava })
    def documentationClasspath = files(mainSourceSets.collect { it.compileClasspath })

    tasks.register('generatePyDoc', Javadoc) {
        group = 'documentation'
        description = 'Generates the python documentation for the project'
        source(documentationSources)
        classpath = documentationClasspath
        destinationDir = new File(docsBuildDir, 'python/JsMacrosAC')
        options.doclet = 'xyz.wagyourtail.doclet.pydoclet.Main'
        options.docletpath = files(docletJarFile)
        (options as CoreJavadocOptions).addStringOption('v', project.version.toString())
    }

    tasks.register('copyPyDoc', Copy) {
        group = 'documentation'
        description = 'Copies the python documentation to the build folder'
        dependsOn('generatePyDoc')
        from(rootProject.file('docs/python'))
        into(new File(docsBuildDir, 'python'))
    }

    tasks.register('generateTSDoc', Javadoc) {
        group = 'documentation'
        description = 'Generates the typescript documentation for the project'
        source(documentationSources)
        classpath = documentationClasspath
        destinationDir = new File(docsBuildDir, 'typescript/headers')
        options.doclet = 'xyz.wagyourtail.doclet.tsdoclet.Main'
        options.docletpath = files(docletJarFile)
        (options as CoreJavadocOptions).addStringOption('v', project.version.toString())
    }

    tasks.register('copyTSDoc', Copy) {
        group = 'documentation'
        description = 'Copies the typescript files to the build folder'
        dependsOn('generateTSDoc')
        from(rootProject.file('docs/typescript'))
        into(new File(docsBuildDir, 'typescript'))
    }

    tasks.register('generateWebDoc', Javadoc) {
        group = 'documentation'
        description = 'Generates the web documentation for the project'
        source(documentationSources)
        classpath = documentationClasspath
        destinationDir = new File(docsBuildDir, 'web')
        options.doclet = 'xyz.wagyourtail.doclet.webdoclet.Main'
        options.docletpath = files(docletJarFile)
        (options as CoreJavadocOptions).addStringOption('v', project.version.toString())
        (options as CoreJavadocOptions).addStringOption('mcv', providers.gradleProperty('minecraft_version').get())
        (options as StandardJavadocDocletOptions).links(
                'https://docs.oracle.com/javase/8/docs/api/',
                'https://www.javadoc.io/doc/org.slf4j/slf4j-api/1.7.30/',
                'https://javadoc.io/doc/com.neovisionaries/nv-websocket-client/latest/'
        )
    }

    tasks.register('copyWebDoc', Copy) {
        group = 'documentation'
        description = 'Copies the web documentation to the build folder'
        dependsOn('generateWebDoc')
        from(rootProject.file('docs/web'))
        into(new File(docsBuildDir, 'web'))
        inputs.property('version', project.version.toString())
        filesMatching('index.html') {
            expand(version: project.version.toString())
        }
    }

    tasks.register('createDistDocs', Copy) {
        group = 'distribution'
        description = 'Packages generated documentation into the dist directory'
        dependsOn('prepareDist', 'copyPyDoc', 'copyTSDoc', 'copyWebDoc')
        from(docsBuildDir)
        into(distDirFile)
    }

    def baseJarTasks = loaders.collectEntries { loader ->
        def loaderProject = project(":${loader}")
        def sourceTaskName = loader == 'fabric' ? 'remapJar' : 'jar'
        def taskName = "package${loader.capitalize()}ModJar"
        [(loader): tasks.register(taskName, Copy) {
            group = 'distribution'
            description = "Packages ${loader} mod jar into dist"
            dependsOn('prepareDist', loaderProject.tasks.named(sourceTaskName))
            def jarFile = loaderProject.tasks.named(sourceTaskName).flatMap { it.archiveFile }
            from(jarFile)
            rename { "${modId}-${mcVersion}-${loader}-${project.version}.jar" }
            into(distDirFile)
            duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        }]
    }

    def extensionJarTasks = extensions.collect { ext ->
        tasks.register("package${ext.extId.capitalize()}Extension", Copy) {
            group = 'distribution'
            description = "Packages ${ext.extId} extension"
            def extJar = project(ext.path).tasks.named('jar').flatMap { it.archiveFile }
            dependsOn('prepareDist', extJar)
            from(extJar)
            rename { "${modId}-ext-${ext.extId}-${mcVersion}-${project.version}.jar" }
            into(new File(distDirFile, 'extensions'))
            duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        }
    }

    def devkitTasks = [tasks.register('packageDevkit', Zip) {
        group = 'distribution'
        description = 'Packages devkit bundle'
        dependsOn('prepareDist', 'copyPyDoc', 'copyTSDoc', 'copyWebDoc')
        destinationDirectory.set(distDir)
        archiveFileName.set("${modId}-devkit-${mcVersion}-${project.version}.zip")
        from(docsBuildDir) {
            include 'web/**'
            include 'typescript/**'
            include 'python/**'
        }
    }]

    def extensionPackTasks = [tasks.register('packageExtensionsPack', Zip) {
        group = 'distribution'
        description = 'Bundles all extensions into the config/jsMacros/extensions layout'
        dependsOn('prepareDist', extensionJarTasks, 'createDistExtensions', 'createDistDocs', baseJarTasks.values())
        destinationDirectory.set(distDir)
        archiveFileName.set("${modId}-extensions-${mcVersion}-${project.version}.zip")
        into('config/jsMacros/extensions') {
            from(new File(distDirFile, 'extensions')) {
                include "*-${project.version}.jar"
            }
        }
    }]

    tasks.register('createDistMods') {
        group = 'distribution'
        description = 'Packages loader specific jars into the dist directory'
        dependsOn(baseJarTasks.values())
    }

    tasks.register('createDistExtensions') {
        group = 'distribution'
        description = 'Packages standalone extensions into the dist directory'
        dependsOn(extensionJarTasks)
    }

    tasks.register('packageSourceZip', Zip) {
        group = 'distribution'
        description = 'Creates a source archive matching the distribution version'
        dependsOn('prepareDist')
        destinationDirectory.set(distDir)
        archiveFileName.set(artifactBaseName.map { "${it}-source.zip" })
        from(projectDir) {
            include '**/*'
            exclude '.git/**', '.gradle/**', '**/.gradle/**', 'build/**', '**/build/**', 'dist/**'
        }
    }

    tasks.register('createDist') {
        group = 'distribution'
        description = 'Assembles documentation, mods, extensions, devkits, and sources into dist/'
        dependsOn('createDistDocs', 'createDistMods', 'createDistExtensions', devkitTasks, extensionPackTasks, 'packageSourceZip')
    }
}

tasks.register('prepareDist') {
    group = 'distribution'
    description = 'Cleans and recreates the dist directory'
    doLast {
        project.delete(distDirFile)
        distDirFile.mkdirs()
    }
}

tasks.register('printArtifactName') {
    group = 'distribution'
    description = 'Prints the canonical artifact name for CI workflows'
    doLast {
        println artifactBaseName.get()
    }
}

tasks.register('printVersion') {
    group = 'distribution'
    description = 'Prints the computed project version for CI workflows'
    doLast {
        println project.version
    }
}

tasks.register('printMinecraftVersion') {
    group = 'distribution'
    description = 'Prints the targeted Minecraft version for CI workflows'
    doLast {
        println mcVersion
    }
}
